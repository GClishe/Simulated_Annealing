import random
from copy import deepcopy
import numpy as np
import math
import time

#matplotlib is used for visualization/debugging. I do not expect to need it in the final result
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle

def cool(T: int) -> float: 
    # defines the cooling schedule for the temperature T
    return 0.95*T

def cost(state: dict) -> int:
    """
    Return cost associated with a particular state. Cost is the total manhattan distance 
    separating connected cells (those on the same net). Distance between connected cells
    is |x_i - x_j| + |y_i-y_j|. cost(state) returns sum of all distances.  
    
    :param state: Placement state describing grid size, cell locations, and net connectivity.
    :type state: dict
    :return: Total Manhattan wirelength summed over all nets.
    :rtype: int
    """
    # a potential optimization once the rest of the algorithm is written might be to instead only recompute the length of nets connected to a moved cell. 

    total_length = 0                                     # initializes length (cost) to 0
    for net in state['nets']:
        cell_i, cell_j = net['cells']                    # grabs the two connected cells on each net

        x_i, y_i = state['cells'][cell_i]['position']     # grabs the coordinates associated with cell_i in the state['cells'] dictionary
        x_j, y_j = state['cells'][cell_j]['position']     # same but for cell_j

        wire_length = abs(x_i - x_j) + abs(y_i - y_j)    # computes manhattan length between cell_i and cell_j
        total_length += wire_length                      # adds length of this net to the total length
    
    return total_length

# search_ring is essentially a helper function designed for use in the perturb() function. 
def search_ring(state: dict, target_coordinates: tuple[int, int], grid_size: int, seed: int = None) -> tuple[int, int]:
    """
    Searches outward from a target coordinate in Manhattan distance "rings" and returns
    a randomly selected available (not locked, in-bounds) from the nearest ring. 

    First searches ring of Manhattan distance of 1 from the target, and proceeds searching
    until the ring size equals twice the grid_size parameter. If multiple cells exist at the
    same minimum distance, one is chosen randomly. Seed parameter ensures reproducability. 
    
    :param state: Placement state dictionary.
    :type state: dict
    :param target_coordinates: (x, y) coordinates of the target cell.
    :type target_coordinates: tuple[int, int]
    :param grid_size: Size of the (square) grid. Valid coordinates satisfy
                    0 <= x < grid_size and 0 <= y < grid_size.
    :type grid_size: int
    :param seed: Seed for random number generator.
    :type: int
    :return: Coordinates (x, y) of a nearest available cell.
    :rtype: tuple[int, int]
    :raises ValueError: If no available cell exists within the grid.
    """
    
    rng = random.Random(seed)                                                       # creates an object that generates random sequence of numbers according to a seed. 

    X, Y = target_coordinates                                                       # unpacks the target_coordinates tuple to X and Y variables

    locked_coordinates = {
        cell["position"] for cell in state["cells"].values() if cell["fixed"]        # creates a set containing all locked coordinates. Set is chosen because it is easy to search and order is not needed
    }

    def in_bounds(coord: tuple[int, int], grid_size: int) -> bool:
        # helper function that decides if a coordinate is is in the grid. 
        return (0 <= coord[0] < grid_size) and (0 <= coord[1] < grid_size)

    for ring_size in range(1, 2 * grid_size + 1):                                   # ring_size (manhattan distance to target) can be at most 2*grid_size
        candidate_moves = set()                                                     # the goal is to randomly select one cell that is ring_size away from the target. Set is chosen over list to remove duplicates

        for i in range(ring_size + 1):
            j = ring_size - i                                                       # with this setup, we will iterate through all i,j pairs such that i + j = ring_size. This will allow us to generate all coordinates on the ring
            coords = [(X+i, Y+j), (X+i, Y-j), (X-i, Y+j), (X-i, Y-j)]               # this actually creates the coordinates. However, it does allow duplicates (for example, (X+i, Y+j) and (X+i, Y-j) are the same when j==0). This is why candidate_moves is a set.

            for coord in coords:                                                    # checking each of the four coordinates generated by an i,j pair
                if in_bounds(coord, grid_size) and coord not in locked_coordinates:
                    candidate_moves.add(coord)                                      # if it is both in the boundary and not locked, then we add it to the candidate moves. 

        if candidate_moves:   
            return rng.choice(tuple(candidate_moves))                               # choose a random value in candidate_moves (converted to tuple first, as .choice doesnt work with sets) according to the seed. 

    raise ValueError("There are no available cells. Either all cells are locked or grid_size is invalid.")

def perturb(state: dict, seeds: list[int, int, int] = [None, None, None]) -> dict:
    """
    Proposes a signle perturbation (move) to the current placement solution. The move is generated in three randomized steps:
    First, you choose a net that contains at least one unlocked cell, with probability proportional to the net's current
    wire length. Next, choose one unlocked cell on that net to move. Third, move that cell to a nearby coordinate close to the 
    other cell on that net, using the search_ring() function. If the desination coordinate is occupied, swap the two cells. 

    To ensure reproducibility despite randomness, we seed each random number generator with a different seed. seeds[0] seeds
    the net selection, seed[1] seeds the unlocked-cell selection, and seeds[2] is forwarded to search_ring() for destination 
    selection.
    
    :type state: dict
    :param seeds: Three seeds controlling the random choices made by this function.
    :type seeds: list[int, int, int]
    :return: The modified placement dictionary (cells may be moved / swapped).
    :rtype: dict
    :raises ValueError: If no nets contain an unlocked cell (cannot generate a move).
    """
    
    # the code below reuses the same code in the cost function. Once I have an implementation for each part of the SA algorithm, I will rewrite to remove repeated code.
    nets = []
    weights = []
    max_length = 2 * (state['grid_size'] + 1)               # nets will be weighted based on their length compared to the max length. There is no need for the weights to be normalized.

    for net in state['nets']:
        cell_i, cell_j = net['cells']                       # grabs the two connected cells on each net

        x_i, y_i = state['cells'][cell_i]['position']       # grabs the coordinates associated with cell_i in the state['cells'] dictionary
        x_j, y_j = state['cells'][cell_j]['position']       # same but for cell_j

        wire_length = abs(x_i - x_j) + abs(y_i - y_j)       # manhattan distance

        # adds length and weight as parameters attached to each net
        net['length'] = wire_length
        net['weight'] = wire_length / max_length

        # if either of the cells are unlocked, add the net to the `nets` list (and its weight to the `weights` list)
        if any(state['cells'][cell_name]['fixed'] is False for cell_name in net['cells']): 
            weights.append(net['weight'])
            nets.append(net)

    # check if nets is empty. If so, raise a ValueError
    if not nets:   
        raise ValueError("No nets contain an unlocked cell, so no perturbation can be generated.")

    # choose a net probabilistically based on its weight relative to the other nets.
    # because `nets` and `weights` contains only nets with unlocked cells, chosen_net is also guaranteed
    # to have at least one unlocked cell
    rng_net = random.Random(seeds[0])
    chosen_net = rng_net.choices(nets, weights=weights, k=1)[0]

    # now we need to randomly choose either one of the non-fixed cells on that net. If only one cell is fixed, we must choose the other one.
    unlocked_cell_mask = [state['cells'][cell_name]['fixed'] is False for cell_name in chosen_net['cells']]     # creates a [True/False, True/False] mask describing cells that are unlocked or not
    unlocked_cells = np.array(chosen_net['cells'])[unlocked_cell_mask]                                          # uses the mask to create an array that contains the unlocked cell(s) on that net. len(unlocked_cells) is either 1 or 2.

    rng_cell = random.Random(seeds[1])
    cell_to_move = rng_cell.choices(list(unlocked_cells), k=1)[0]                                               # randomly chooses one of the cells in unlocked_cells. choices(...) returns a list, so [0] extracts the string.
    cell_to_move_original_coords = state['cells'][cell_to_move]['position']                                    # original coordinates of the cell we are moving. This will be useful for swapping if the new position is occupied by a unlocked cell. 

    # Now I want to move that cell to be close to its net-neighbor (target_cell).
    for cell in chosen_net['cells']:
        if cell != cell_to_move:
            target_cell = cell                    # the cell on chosen_net that will not be moved is the target cell.

    # now find the coordinates of the new position of cell_to_move
    new_coords = search_ring(
        state=state,
        target_coordinates=state['cells'][target_cell]['position'],
        grid_size=state['grid_size'],
        seed=seeds[2]
    ) 

    # ow we need to actually move this cell to the new coords. First step will be to check if the new coords are occupied. If so, swap them.
    for cell in state['cells'].values():
        if new_coords == cell['position']: 
            if cell['fixed'] is True:                            #checks if the cell that we are trying to relocate is fixed. This should never happen, but if it does, this should handle it.
                raise ValueError("Desination occupied by fixed cell.")
            cell['position'] = cell_to_move_original_coords      # moves the cell occupying the new coordinates to the old position of the cell we are moving

    state['cells'][cell_to_move]['position'] = new_coords        # updates the cell we are moving to be in the new position.
    state['cells'][cell_to_move]['fixed'] = True                 # Fixes the position of the moved cell (but not the cell that used to be there, if one existed)

    return state

def accept_move(d_cost: int, T: int, k: int, seed: int) -> bool:
    """
    Decides whether or not to accept a proposed move. A move that does not increase cost (d_cost <= 0) is always
    accepted. A move that increases cost is accepted probabilistically according to the boltzmann factor
    exp(-d_cost / (k * T))
    
    :param d_cost: Change in cost resulting from the proposed move
                   (new_cost - current_cost).
    :type d_cost: int
    :param T: Current annealing temperature. Higher values increase the
              probability of accepting worse moves.
    :type T: int
    :param k: Scaling factor that controls sensitivity to cost increases.
    :type k: int
    :param seed: Seed for the random number generator to ensure reproducible
                 decisions.
    :type seed: int
    :return: True if the move is accepted, False otherwise.
    :rtype: bool
    """
    if d_cost <= 0:
        return True
    boltz = math.exp(-1*d_cost / (k*T))
    r = random.Random(seed).random()        # chooses random number between 0 and 1 with a seed
    if r < boltz:
        return True
    else: 
        return False

#below is a purely chatgpt generated code specifically designed to test my perturb() function. I will be removing this function in the final version. 
def plot_placement(state, *, show_nets=True, label_cells=True, title=None):
    """
    Plot an NxN placement grid with shaded occupied cells and optional net lines.
    Coordinates are assumed to be integer cell indices with (0,0) at bottom-left.
    """
    N = state["grid_size"]

    fig, ax = plt.subplots(figsize=(6, 6))

    # --- grid lines (cell boundaries) ---
    for k in range(N + 1):
        ax.plot([k, k], [0, N], linewidth=1)
        ax.plot([0, N], [k, k], linewidth=1)

    # --- occupied cells ---
    for name, info in state["cells"].items():
        x, y = info["position"]
        ax.add_patch(Rectangle((x, y), 1, 1, alpha=0.35))  # no explicit color
        if label_cells:
            ax.text(x + 0.5, y + 0.5, name, ha="center", va="center", fontsize=8)

    # --- nets (center-to-center) ---
    if show_nets and "nets" in state:
        for net in state["nets"]:
            a, b = net["cells"]
            xa, ya = state["cells"][a]["position"]
            xb, yb = state["cells"][b]["position"]
            ax.plot([xa + 0.5, xb + 0.5], [ya + 0.5, yb + 0.5],
                    linestyle="--", linewidth=1, alpha=0.7)

    # --- axes formatting ---
    ax.set_xlim(0, N)
    ax.set_ylim(0, N)
    ax.set_aspect("equal", adjustable="box")
    ax.set_xticks(range(N))
    ax.set_yticks(range(N))
    ax.set_xlabel("x")
    ax.set_ylabel("y")
    ax.set_title(title or "Placement (occupied cells + nets)")
    plt.show()

def unfix_all(state: dict) -> None:
    # All movable cells are set to the fixed = False state. 
    for cell in state['cells'].values():
        if cell['type'] == 'MOVABLE':
            cell['fixed'] = False